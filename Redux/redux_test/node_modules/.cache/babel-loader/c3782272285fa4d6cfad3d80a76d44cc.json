{"ast":null,"code":"// 容器组件不能rcc，他是一个桥梁\n// 引入左手引入右手\n//引入Count的UI组件(左手)\nimport CountUI from \"../../components/Count\";\nimport { createIncrementAction } from \"../../redux/count_action\"; //引入redux，就把最核心的store引入就行(右手)\n// import store from '../../redux/store'\n// 右手：容器组件的  store  需要在App.jsx里面用props引入\n//引入connect用于连接UI组件与redux\n\nimport { connect } from \"react-redux\"; //不需要，库已经帮你做了\n// import store from '../../redux/store'\n//本质上，a传递状态\n//你没有机会写 <CountUI a=\"1\">，我们通过函数的返回值来传递a=\"1\"\n//a函数返回的对象中的key就作为传递给UI组件的props的key\n//value就作为传递给UI组件props的value\n// react-redux已经自动帮你接收了state\n\nfunction mapStateToProps(state) {\n  return {\n    count: state\n  }; //相当于<CountUI n={900} />\n} // 本质上，b传递操作状态的方法\n//a函数返回的对象中的key就作为传递给UI组件的props的key\n//value就作为传递给UI组件props的value\n\n\nfunction mapDispatchToProps(dispatch) {\n  return {\n    increment: number => // 通知redux指向加法，dispatch一个action\n    dispatch(createIncrementAction(number))\n  };\n} // 连接左右手`\n// connect是一个函数，返回值还是一个函数，左手连接，就是放入参数在第二个函数中\n// UI组件是容器组件的子组件，那么我们直接渲染容器组件就行\n// connect第一次调用的时候传入两个参数，且必须是参数\n\n\nexport default connect(mapStateToProps, mapDispatchToProps)(CountUI); // const CountContainer = connect()(CountUI)\n// 虽然不直观，但是其实容器组件是UI组件的父组件\n// 那不直观，如何父亲给儿子传递props呢","map":{"version":3,"sources":["/Users/dyq/Desktop/react/Redux/redux_test/src/containers/Count/index.jsx"],"names":["CountUI","createIncrementAction","connect","mapStateToProps","state","count","mapDispatchToProps","dispatch","increment","number"],"mappings":"AAAA;AACA;AAEA;AACA,OAAOA,OAAP,MAAoB,wBAApB;AAEA,SAASC,qBAAT,QAAsC,0BAAtC,C,CAEA;AACA;AACA;AAEA;;AACA,SAASC,OAAT,QAAwB,aAAxB,C,CACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AACA,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AAC9B,SAAO;AAAEC,IAAAA,KAAK,EAAED;AAAT,GAAP,CAD8B,CAE9B;AACD,C,CAED;AAEA;AACA;;;AACA,SAASE,kBAAT,CAA4BC,QAA5B,EAAsC;AACpC,SAAO;AACLC,IAAAA,SAAS,EAAGC,MAAD,IACT;AACAF,IAAAA,QAAQ,CAACN,qBAAqB,CAACQ,MAAD,CAAtB;AAHL,GAAP;AAKD,C,CAED;AACA;AACA;AACA;;;AACA,eAAeP,OAAO,CAACC,eAAD,EAAkBG,kBAAlB,CAAP,CAA6CN,OAA7C,CAAf,C,CACA;AAEA;AACA","sourcesContent":["// 容器组件不能rcc，他是一个桥梁\n// 引入左手引入右手\n\n//引入Count的UI组件(左手)\nimport CountUI from \"../../components/Count\";\n\nimport { createIncrementAction } from \"../../redux/count_action\";\n\n//引入redux，就把最核心的store引入就行(右手)\n// import store from '../../redux/store'\n// 右手：容器组件的  store  需要在App.jsx里面用props引入\n\n//引入connect用于连接UI组件与redux\nimport { connect } from \"react-redux\";\n//不需要，库已经帮你做了\n// import store from '../../redux/store'\n\n//本质上，a传递状态\n\n//你没有机会写 <CountUI a=\"1\">，我们通过函数的返回值来传递a=\"1\"\n//a函数返回的对象中的key就作为传递给UI组件的props的key\n//value就作为传递给UI组件props的value\n// react-redux已经自动帮你接收了state\nfunction mapStateToProps(state) {\n  return { count: state };\n  //相当于<CountUI n={900} />\n}\n\n// 本质上，b传递操作状态的方法\n\n//a函数返回的对象中的key就作为传递给UI组件的props的key\n//value就作为传递给UI组件props的value\nfunction mapDispatchToProps(dispatch) {\n  return {\n    increment: (number) =>\n      // 通知redux指向加法，dispatch一个action\n      dispatch(createIncrementAction(number)),\n  };\n}\n\n// 连接左右手`\n// connect是一个函数，返回值还是一个函数，左手连接，就是放入参数在第二个函数中\n// UI组件是容器组件的子组件，那么我们直接渲染容器组件就行\n// connect第一次调用的时候传入两个参数，且必须是参数\nexport default connect(mapStateToProps, mapDispatchToProps)(CountUI);\n// const CountContainer = connect()(CountUI)\n\n// 虽然不直观，但是其实容器组件是UI组件的父组件\n// 那不直观，如何父亲给儿子传递props呢\n"]},"metadata":{},"sourceType":"module"}