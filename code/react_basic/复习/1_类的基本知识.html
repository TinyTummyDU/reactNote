<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>1_类的基本知识</title>
  </head>
  <body>
    <script type="text/javascript">
      //创建一个Person类
      class Person {
        //构造器方法
        constructor(name, age) {
          //构造器的this是谁？-类的实例对象
          this.name = name;
          this.age = age;
        }
        //一般方法
        speak() {
          //speak方法放在了哪里？--类的原型对象上,供实例使用
          //通过person实例调用speak时，speak中的this就是Person实例
          console.log(`我叫${this.name},我的年龄是${this.age}`);
        }
      }

      class Student extends Person {
        //新建的constructor必须写super，除非你不写构造器
        constructor(name, age, grade) {
          //super必须放在最前面
          super(name, age);
          this.grade = grade;
          this.school = "尚硅谷";
        }
        //重写从父类继承过来的方法
        speak() {
          console.log(
            `我叫${this.name},我的年龄是${this.age},我读的是${this.grade}`
          );
        }
        study() {
          console.log(`我爱学习`);
        }
      }

      class Car {
        constructor(name, price) {
          this.name = name;
          this.price = price;
        }
        //类里可以直接写赋值语句，如下代码的含义是：给Car的实力对象添加一个属性，名为a，值为1
        //不需要非要在构造器里面写属性，但不是定值，要接值的时候就要写在constructor里
        wheelNumber = 4;
      }

      /* 
      总结
      1.类中的构造器不是必须写的，要对实例进行一些初始化的操作时候，如添加指定属性时才写。
      2.如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的。
      3.类中所定义的方法，都是放在了类的原型对象，供实例去使用
       */

      //创建一个Person实例对象
      const p1 = new Person("Tom", 12);
      const p2 = new Person("Vicky", 20);

      console.log(p1);
      console.log(p2);
      p1.speak();
      p2.speak();

      // call,apply,bind 都能改变this指向，这里就不是用p1去调用speak了
      p1.speak.call({ a: 1, b: 2 });

      //创建一个Person实例对象
      const s1 = new Student("Tom", 12, 1);

      console.log(s1);
      //原型链
      s1.speak();
      s1.study();
    </script>
  </body>
</html>
